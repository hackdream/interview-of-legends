## 你觉得 Java 好在哪儿？

这种笼统的问题如果对某些知识点没有深入、系统地认识绝对会蒙！

所以为什么经常碰到面试官问你一些空、大的问题？其实就是考察你是否有形成体系的理解。

回到问题本身。我觉得可以从跨平台、垃圾回收、生态三个方面来阐述。

首先 Java 是跨平台的，不同平台执行的机器码是不一样的，而 Java 因为加了一层中间层 JVM ，所以可以做到一次编写多平台运行，即 「Write once,Run anywhere」。

编译执行过程是先把 Java 源代码编译成字节码，字节码再由 JVM 解释或 JIT 编译执行，而因为 JIT 编译时需要预热的，所以还提供了 AOT（Ahead-of-Time Compilation），可以直接把字节码转成机器码，来让程序重启之后能迅速拉满战斗力。

（解释执行比编译执行效率差，你想想每次给你英语让你翻译阅读，还是直接给你看中文，哪个快？）

Java 还提供垃圾自动回收功能，虽说手动管理内存意味着自由、精细化地掌控，但是很容易出错。

在内存较充裕的当下，将内存的管理交给 GC 来做，减轻了程序员编程的负担，提升了开发效率，更加划算！

然后现在 Java 生态圈太全了，丰富的第三方类库、网上全面的资料、企业级框架、各种中间件等等，总之你要的都有。

基本上这样答差不多了，之后等着面试官延伸。

当然这种开放性问题没有固定答案，我的回答仅供参考。

## Java 按值传递还是按引用传递？

**Java 只有按值传递，不论是基本类型还是引用类型**。

基本类型是值传递很好理解，引用类型有些同学可能有点理解不了，特别是初学者。

JVM 内存有划分为栈和堆，局部变量和方法参数是在栈上分配的，基本类型和引用类型都占 4 个字节，当然 long 和 double 占 8 个字节。

而对象所占的空间是在堆中开辟的，引用类型的变量存储对象在堆中地址来访问对象，所以传递的时候可以理解为把变量存储的地址给传递过去，因此引用类型也是值传递。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112539293.png)

## 接口和抽象类有什么区别？

接口：只能包含抽象方法，不能包含成员变量，当 has a 的情况下用接口。

接口是对行为的抽象，类似于条约。在 Java 中接口可以多实现，从 has a 角度来说接口先行，也就是先约定接口，再实现。

抽象类: 可以包含成员变量和一般方法和抽象方法，当 is a 并且主要用于代码复用的场景下使用抽象类继承的方式，子类必须实现抽象类中的抽象方法。

在 Java 中只支持单继承。从 is a 角度来看一般都是先写，然后发现代码能复用，然后抽象一个抽象类。

## 什么是序列化？什么是反序列化？

序列化其实就是将对象转化成可传输的字节序列格式，以便于存储和传输。

因为对象在 JVM 中可以认为是“立体”的，会有各种引用，比如在内存地址Ox1234 引用了某某对象，那此时这个对象要传输到网络的另一端时候就需要把这些引用“压扁”。

因为网络的另一端的内存地址 Ox1234 可以没有某某对象，所以传输的对象需要包含这些信息，然后接收端将这些扁平的信息再反序列化得到对象。

所以**反序列化就是将字节序列格式转换成对象的过程**。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112408826.png)

我再扩展一下 Java 序列化。

> 首先说一下 Serializable，这个接口没有什么实际的含义，就是起标记作用。

来看下源码就很清楚了，除了 String、数组和枚举之外，如果实现了这个接口就走`writeOrdinaryObject`，否则就序列化就抛错。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112426413.png)

> serialVersionUID 又有什么用？

`private static final long serialVersionUID = 1L;`

 想必经常会看到这样的代码，这个 ID 其实就是用来验证序列化的对象和反序列化对应的对象ID 是否一致。

所以这个 ID 的数字其实不重要，无论是 1L 还是 idea 自动生成的，只要序列化时候对象的 serialVersionUID 和反序列化时候对象的 serialVersionUID 一致的话就行。

如果没有显示指定 serialVersionUID ，则编译器会根据类的相关信息自动生成一个，可以认为是一个指纹。

所以如果你没有定义一个 serialVersionUID 然后序列化一个对象之后，在反序列化之前把对象的类的结构改了，比如增加了一个成员变量，则此时的反序列化会失败。

因为类的结构变了，生成的指纹就变了，所以 serialVersionUID 就不一致了。

所以 serialVersionUID 就是起验证作用。

> Java 序列化不包含静态变量

简单地说就是序列化之后存储的内容不包含静态变量的值，看下下面的代码就很清晰了。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112441786.png)

## 什么是不可变类？

不可变类指的是无法修改对象的值，比如 String 就是典型的不可变类，当你创建一个 String 对象之后，这个对象就无法被修改。

因为无法被修改，所以像执行`s += "a";` 这样的方法，其实返回的是一个新建的 String 对象，老的 s 指向的对象不会发生变化，只是 s 的引用指向了新的对象而已。

所以才会有不要在字符串拼接频繁的场景不要使用 + 来拼接，因为这样会频繁的创建对象。

不可变类的好处就是**安全**，因为知晓这个对象不可能会被修改，因此可以放心大胆的用，在多线程环境下也是线程安全的。

> 如何实现一个不可变类？

这个问题我被面试官问过，其实就参考 String 的设计就行。

String 类用 final 修饰，表示无法被继承。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112501169.png)

String 本质是一个 char 数组，然后用 final 修饰，不过 final 限制不了数组内部的数据，所以这还不够。

所以 value 是用 private 修饰的，并且没有暴露出 set 方法，这样外部其实就接触不到 value 所以无法修改。

当然还是有修改的需求，比如 replace 方法，所以这时候就需要返回一个新对象来作为结果。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112521363.png)

总结一下就是私有化变量，然后不要暴露 set 方法，即使有修改的需求也是返回一个新对象。

## Exception 和 Error 的区别知道吗？

Exception 是程序正常运行过程中可以预料到的意外情况，应该被开发者捕获并且进行相应的处理。

Error 是指在正常情况下不太可能出现的情况，绝大部分的 Error 都会导致程序处于不正常、不可恢复的状态，也就是挂了。

所以不便也不需被开发者捕获，因为这个情况下你捕获了也无济于事。

Exception和Error都是继承了Throwable类，在Java代码中只有继承了Throwable类的实例才可以被throw或者被catch。

顺便我再提一提异常处理的注意点，之前写过文章总结过：

> 1. **尽量不要捕获类似Exception这样通用的异常，而应该捕获特定的异常。**

软件工程是一门协作的艺术，在日常的开发中我们有义务使自己的代码能更直观、清晰的表达出我们想要表达的信息。

但是如果你什么异常都用了Exception，那别的开发同事就不能一眼得知这段代码实际想要捕获的异常，并且这样的代码也会捕获到可能你希望它抛出而不希望捕获的异常。

> 2. **不要"吞"了异常**

如果我们捕获了异常，不把异常抛出，或者没有写到日志里，那会出现什么情况？线上除了 bug 莫名其妙的没有任何的信息，你都不知道哪里出错以及出错的原因。

这可能会让一个简单的bug变得难以诊断，而且有些同学比较喜欢用 catch 之后用e.printStackTrace()，在我们产品中通常不推荐用这种方法，一般情况下这样是没有问题的但是这个方法输出的是个标准错误流。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210303201223649.png)

比如是在分布式系统中，发生异常但是找不到stacktrace。

所以最好是输入到日志里，我们产品可以自定义一定的格式，将详细的信息输入到日志系统中，适合清晰高效的排查错误。

> 3. **不要延迟处理异常**

比如你有个方法，参数是个 name，函数内部调了别的好几个方法，其实你的name传的是 null 值，但是你没有在进入这个方法或者这个方法一开始就处理这个情况，而是在你调了别的好几个方法然后爆出这个空指针。

这样的话明明你的出错堆栈信息只需要抛出一点点信息就能定位到这个错误所在的地方，进过了好多方法之后可能就是一坨堆栈信息。

>4. **只在需要try-catch的地方try-catch，try-catch的范围能小则小**

只要必要的代码段使用try-catch，不要不分青红皂白try住一坨代码，因为try-catch中的代码会影响JVM对代码的优化，例如重排序。

>5. **不要通过异常来控制程序流程**

一些可以用if/else的条件语句来判断例如null值等，就不要用异常，异常肯定是比一些条件语句低效的，有 CPU 分支预测的优化等。

而且每实例化一个Exception都会对栈进行快照，相对而言这是一个比较重的操作，如果数量过多开销就不能被忽略了。

> 6. **不要在finally代码块中处理返回值或者直接return**

在finally中return或者处理返回值会让发生很诡异的事情，比如覆盖了 try 中的return，或者屏蔽的异常。

## 面向对象编程和面向过程编程的区别？

**面向对象编程**(Object Oriented Programming，OOP)是一种编程范式或者说编程风格。

**把类或对象作为基本单元来组织代码**，并且运用提炼出的：封装、继承和多态来作为代码设计指导。

**面向过程编程**是以过程作为基本单元来组织代码的，过程其实就是动作，对应到代码中来就是函数，面向过程中函数和数据是分离的，数据其实就是成员变量。

而面向对象编程的类中数据和动作是在一起的，这也是两者的一个显著的区别。

如果对这两个概念还是比较模糊的话，可以看我写的这篇文章，4800多字来讲面向对象和面向过程，看完之后肯定懂！[面向对象和面向过程解析](https://mp.weixin.qq.com/s/j5tocng0bQmQSXJdaWeaSA)

## 重载与重写的区别？

重载：指的是方法名相同，参数类型或者顺序或个数不同，**这里要注意和返回值没有关系**，方法的签名是名字和参数列表，不包括返回值。

重写：指的是子类重写父类的方法，方法名和参数列表都相同，也就是方法签名是一致的。重写的子类逻辑抛出的异常和父类一样或者是其父类异常的子类，并且方法的访问权限不得低于父类。

简单的理解为儿子不要超过爸爸，要尊老爱幼。

## 什么是内部类，有什么用？

内部类顾名思义就是定义在一个类的内部的类，按位置分：在成员变量的位置定义，则是成员内部类，在方法内定义，则是局部内部类。

如果用 static 修饰则为静态内部类，还有匿名内部类。

一般而言只会用成员内部类、静态内部类和匿名内部类。

成员内部类可以使用外部类的所有成员变量以及方法，包括 private 的。

静态内部类只能使用外部类的静态成员变量以及方法。

匿名类常用来作为回调，使用的时候再实现具体逻辑来执行回调。

实际上内部类是一个编译层面的概念，像一个语法糖一样，经过编译器之后其实内部类会提升为外部顶级类，和外部类没有任何区别，所以**在 JVM 中是没有内部类的概念的**。

一般情况下非静态内部类用在内部类和其他类无任何关联，专属于这个外部类使用，并且也便于调用外部类的成员变量和方法，比较方便。

静态外部类其实就等于一个顶级类，可以独立于外部类使用，所以更多的只是表明类结构和命名空间。

## JDK8 有哪些新特性？

JDK8 较为重要和平日里经常被问的特性如下：

- 用元空间替代了永久代。
- 引入了 Lambda 表达式。
- 引入了日期类、接口默认方法、静态方法。
- 新增 Stream 流式接口

然后相信你们对 HashMap 和 ConcurrentHashMap 有一定的准备，所以抛出来

- 修改了 HashMap 和 ConcurrentHashMap 的实现（等着八股文之问）

- 新增了 CompletableFuture 、StampedLock 等并发实现类。

像一些中间件异步化代码都用了 CompletableFuture 来实现，所以还是得做一些了解的，如果不熟悉这条就不用提了。

## String，Stringbuffer，StringBuilder的区别？

String 是 Java 中基础且重要的类，并且 String 也是 Immutable 类的典型实现，被声明为 final class，除了 hash 这个属性其它属性都声明为 final。

因为它的不可变性，所以例如拼接字符串时候会产生很多无用的中间对象，如果**频繁的进行这样的操作**对性能有所影响。

**StringBuffer 就是为了解决大量拼接字符串时产生很多中间对象问题而提供的一个类**，提供 append 和 add 方法，可以将字符串添加到已有序列的末尾或指定位置。

它的本质是一个线程安全的可修改的字符序列，把所有修改数据的方法都加上了 synchronized。但是保证了线程安全是需要性能的代价的。

在很多情况下我们的字符串拼接操作不需要线程安全，这时候**StringBuilder**登场了，StringBuilder是JDK1.5发布的，它和StringBuffer 本质上没什么区别，就是**去掉了保证线程安全的那部分，减少了开销**。

StringBuffer 和 StringBuilder 二者都继承了 AbstractStringBuilder ，底层都是利用可修改的 char 数组(JDK 9 以后是 byte 数组)。

所以如果我们有大量的字符串拼接，如果能预知大小的话最好在new StringBuffer 或者StringBuilder 的时候设置好 capacity，避免多次扩容的开销。

扩容要抛弃原有数组，还要进行数组拷贝创建新的数组。

## StringBuilder是内部如何实现的？

这是一位读者，八年经验去面试被问的题目，我专门写了一篇文章剖析了下，算是设计类问题。

链接：[StringBuilder实现原理](https://mp.weixin.qq.com/s/lU777Jqik5toXPtwbR9c9Q)

## JDK 和 JRE 的区别？

JRE(Java Runtime Environment)指的是 Java 运行环境，包含了 JVM 和 Java 类库等。

JDK(Java Development Kit) 可以**视为 JRE 的超集**，还提供了一些工具比如各种诊断工具：jstack，jmap，jstat 等。

## 用过哪些 JDK 提供的工具？

这个就考察你平日里面有没有通过一些工具进行问题的分析、排查。

如果你用过肯定很好说，比如之前排查内存异常的时候用 jmap dump下来内存文件用 MAT 进行分析之类的。

如果没用过的话可以试试，自己找场景试验一下。

我列几个之前写过文章的工具，建议自己用用，还是很简单的。

- jps：虚拟机进程状况工具
- jstat：虚拟机统计信息监视工具
- jmap：Java内存映像工具
- jhat：虚拟机堆转储快照分析工具
- jstack：Java堆栈跟踪工具
- jinfo：Java配置信息工具
- VisualVM：图形化工具，可以得到虚拟机运行时的一些信息：内存分析、CPU 分析等等，在 jdk9 开始不再默认打包进 jdk 中。

工具其实还有很多，看看下面这个截图。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112353953.png)

更详细的可以去《深入理解虚拟机Java》第四章查看。

总之就是自己找机会用用，没机会就自己给自己创造机会，防范于未然。

## hashCode 和 equals

hashCode 是属于 Object 的一个方法，并且是个 native 方法，本质就是返回一个哈希码，即一个 int 值，一般是一个对象的内存地址转成的整数。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123124618.png)

equals，我们知道是用来判断两个对象是否相同的，也是属于 Object 的一个方法，并且默认实现如下：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20220123125251520.png)

看到这，是不是觉得 hashCode 和 equals 没啥关系啊？为什么要放在一起说？

确实，一般情况下两者是没啥关系，但，如果是将一个对象用在散列表的相关类的时候，是有关系的。

比如 HashSet，我们常用来得到一个不重复的集合。

现在有个 Yes 类的 HashSet 集合，我只重写了 Yes 类的 equals 方法，表明如果 name 相同就返回 true。

```java
public boolean equals(Object obj) {
    if (this == obj) {
        return true;
    }
    if (obj instanceof Yes) {
        Yes other = (Yes) obj;
        return name.equals(other.name);
    }
    return false;
}
```

就重写一个 equals 的话，HashSet 中会出现相同 name 的 Yes 对象。

原因就是 hashCode 没有重写，那为什么会这样呢？因为 HashSet 是复用 HashMap 的能力存储对象，而塞入 key 的时候要计算 hash 值，可以看到这里实际会调用对象的 hashCode 方法来计算 hash 值。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20220123131304189.png)

然后在具体执行 putVal 方法的时候，相关的判断条件会先判断 hash 值是否相等，如果 hash 值都不同，那就认为这两个对象不相等，这与我们之前设定的 name 一样的对象就是相等的条件就冲突了，我们简单看下源码就清楚了：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20220123131544363.png)

可以看到，相关的判断条件都是先判断 hash 值，如果 hash 值相等，才会接着判断 equals。如果 hash 值不等，这个判断条件直接就 false 了。

因此规定，重写 equals 方法的时候，也要重写 hashCode 方法，这样才能保持条件判断的同步。我建议不管会不会用到散列表，只要你重写  equals  就一起重写 hashCode ，这样肯定不会出错。

## == 和 equals

== 是用来**判断两个对象的是否是同一个对象**，基础类型比较的是指，引用类型比较的是内存地址。

equals 是用来**判断两个对象是否相等**，你可以自定义两个对象的名字一样就是相等的；年龄一样就是相等，这都可以随你定制。

所以两者的差别还是比较明显的。

## 动态代理是什么？

动态代理就是一个代理机制，动态是相对于静态来说的。

代理可以看作是调用目标的一个包装，通常用来在调用真实的目标之前进行一些逻辑处理，消除一些重复的代码。

静态代理指的是我们预先编码好一个代理类，而动态代理指的是运行时生成代理类。

动态更加方便，可以指定一系列目标来动态生成代理类(AOP)，而不像静态代理需要为每个目标类写对应的代理类。

代理也是一种解耦，目标类和调用者之间的解耦，因为多了代理类这一层。

常见的动态代理有 JDK 动态代理 和 CGLIB。

## JDK 动态代理与 CGLIB 区别?

JDK 动态代理是基于接口的，所以**要求代理类一定是有定义接口的**。

CGLIB 基于ASM字节码生成工具，它是通过继承的方式来实现代理类，所以**要注意 final 方法**。

之间的性能随着 JDK 版本的不同而不同，以下内容取自：[haiq的博客](https://www.cnblogs.com/haiq/p/4304615.html)

> - jdk6 下，在运行次数较少的情况下，jdk动态代理与 cglib 差距不明显，甚至更快一些；而当调用次数增加之后， cglib 表现稍微更快一些
> - jdk7 下，情况发生了逆转！在运行次数较少（1,000,000）的情况下，jdk动态代理比 cglib 快了差不多30%；而当调用次数增加之后(50,000,000)， 动态代理比 cglib 快了接近1倍
> - jdk8 表现和 jdk7 基本一致

基本上这样答差不多了，我们再看看 JDK 动态代理实现原理：

1. 首先通过实现 InvocationHandler 接口得到一个切面类。
2. 然后利用 Proxy 根据目标类的类加载器、接口和切面类得到一个代理类。
3. 代理类的逻辑就是把所有接口方法的调用转发到切面类的 invoke() 方法上，然后根据反射调用目标类的方法。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112159415.png)

再深一点点就是代理类会现在静态块中通过反射把所有方法都拿到存在静态变量中，我之前反编译看过代理类，我忙写了一下，大致长这样：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112223174.png)

这一套下来 JDK 动态代理原理应该就很清晰了。

**再来看下 CGLIB**，其实和 JDK 动态代理的实现逻辑是一致，只是实现方式不同。 

```
        Enhancer en = new Enhancer();
        //2.设置父类，也就是代理目标类，上面提到了它是通过生成子类的方式
        en.setSuperclass(target.getClass());
        //3.设置回调函数，这个this其实就是代理逻辑实现类，也就是切面，可以理解为JDK 动态代理的handler
        en.setCallback(this);
        //4.创建代理对象，也就是目标类的子类了。
        return en.create();
```

然后它是通过字节码生成技术而不是反射来实现调用的逻辑，具体就不再深入了。

## 注解是什么原理？

**注解其实就是一个标记**，可以标记在类上、方法上、属性上等，标记自身也可以设置一些值。

有了标记之后，我们就可以**在解析的时候**得到这个标记，然后做一些特别的处理，这就是注解的用处。

比如我们可以定义一些切面，在执行一些方法的时候看下方法上是否有某个注解标记，如果是的话可以执行一些特殊逻辑(RUNTIME类型的注解)。

注解生命周期有三大类，分别是：

- RetentionPolicy.SOURCE：给编译器用的，不会写入 class 文件
- RetentionPolicy.CLASS：会写入 class 文件，在类加载阶段丢弃，也就是运行的时候就没这个信息了
- RetentionPolicy.RUNTIME：会写入 class 文件，永久保存，可以通过反射获取注解信息

所以我上文写的是解析的时候，没写具体是解析啥，因为不同的生命周期的解析动作是不同的。

像常见的：

![image-20210228112243058](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112243058.png)

就是给编译器用的，编译器编译的时候检查没问题就over了，class文件里面不会有 Override 这个标记。

再比如 Spring 常见的 Autowired ，就是 RUNTIME 的，所以**在运行的时候可以通过反射得到注解的信息**，还能拿到标记的值 required 。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112312107.png)

所以注解就是一个标记，可以给编译器用、也能运行时候用。

## 反射用过吗？

如果你用过那就不用我多说啥了，场景说一下，然后等着面试官继续挖。

如果没用过那就说生产上没用过，不过私下研究过反射的原理。

反射其实就是Java提供的能在运行期可以得到对象信息的能力，包括属性、方法、注解等，也可以调用其方法。

一般的编码不会用到反射，在框架上用的较多，因为很多场景需要很灵活，所以不确定目标对象的类型，届时只能通过反射动态获取对象信息。

PS：对反射不了解的，可以网上查查，这里不深入了。

## 泛型有什么用？泛型擦除是什么？

泛型可以把类型当作参数一样传递，使得像一些集合类可以明确存储的对象类型，不用显示地强制转化（在没泛型之前只能是Object，然后强转）。

并且在编译期能识别类型，类型错误则会提醒，增加程序的健壮性和可读性。

泛型擦除指的指参数类型其实在编译之后就被抹去了，也就是生成的 class 文件是没有泛型信息的，所以称之为擦除。

不过这个擦除有个细节，我们来看下代码就很清晰了，代码如下：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112554862.png)

然后我们再来看看编译后的 class 文件。

![image-20210228112610761](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112610761.png)

可以看到 yess 是有类型信息的，所以在代码里写死的泛型类型是不会被擦除的！

这也解释了为什么根据反射是可以拿到泛型信息的，因为这种写死的就没有被擦除！

至于泛型擦除是为了向后兼容，因为在 JDK 5 之前是没有泛型的，所以要保证 JDK 5 之前编译的代码可以在之后的版本上跑，而类型擦除就是能达到这一目标的一个实现手段。

其实 Java 也可以搞别的手段来实现泛型兼容，只是擦除比较容易实现。

更多，可以看我写的这篇[你，可能没完全搞懂 Java 泛型](https://mp.weixin.qq.com/s/XNYfLrnd7tYnTmuf1oyKQg)

主要回答了这几个问题：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20220123160005391.png)

## 深拷贝和浅拷贝?

深拷贝：完全拷贝一个对象，包括基本类型和引用类型，堆内的引用对象也会复制一份。

浅拷贝：仅拷贝基本类型和引用，堆内的引用对象和被拷贝的对象共享。

所以假如拷贝的对象成员间有一个 list，深拷贝之后堆内有 2 个 list，之间不会影响，而浅拷贝的话堆内还是只有一个 list。

比如现在有个 teacher 对象，然后成员里面有一个 student 列表。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210303201307397.png)

因此深拷贝是安全的，浅拷贝的话如果有引用对象则原先和拷贝对象修改引用对象的值会相互影响。

## JDK8 有哪些新特性？

JDK8 较为重要和平日里经常被问的特性如下：

- 用元空间替代了永久代。
- 引入了 Lambda 表达式。
- 引入了日期类、接口默认方法、静态方法。
- 新增 Stream 流式接口

然后相信你们对 HashMap 和 ConcurrentHashMap 有一定的准备，所以抛出来

- 修改了 HashMap 和 ConcurrentHashMap 的实现（等着八股文之问）

- 新增了 CompletableFuture 、StampedLock 等并发实现类。

像一些中间件异步化代码都用了 CompletableFuture 来实现，所以还是得做一些了解的，如果不熟悉这条就不用提了。

## Integer 缓存池知道吗？

因为根据实践发现大部分的数据操作都集中在值比较小的范围，因此 Integer 搞了个缓存池，默认范围是 -128 到 127，可以根据通过设置`JVM-XX:AutoBoxCacheMax=<size>`来修改缓存的最大值，最小值改不了。

实现的原理是int 在自动装箱的时候会调用Integer.valueOf，进而用到了 IntegerCache。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112742081.png)

没什么花头，就是判断下值是否在范围之内，如果是的话去 IntegerCache 中取。

IntegerCache 在静态块中会初始化好缓存值。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112757226.png)

所以这里还有个面试题，就是啥 Integer 127 之内的相等，而超过 127 的就不等了，因为 127 之内的就是同一个对象，所以当然相等。

不仅 Integer 有，Long 也是有的，不过范围是写死的 -128 到 127。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112817173.png)

对了 Float 和 Double 是没有滴，毕竟是小数，能存的数太多了。

## 能说下类加载过程吗?

类加载顾名思义就是把类加载到 JVM 中，而输入一段二进制流到内存，之后经过一番解析、处理转化成可用的 class 类，这就是类加载要做的事情。

二进制流可以来源于 class 文件，或者通过字节码工具生成的字节码或者来自于网络都行，只要符合格式的二进制流，JVM 来者不拒。

类加载流程分为加载、连接、初始化三个阶段，连接还能拆分为：验证、准备、解析三个阶段。

所以总的来看可以分为 5 个阶段：

- 加载：将二进制流搞到内存中来，生成一个 Class 类。

- 验证：主要是验证加载进来的二进制流是否符合一定格式，是否规范，是否符合当前 JVM 版本等等之类的验证。

- 准备：为静态变量(类变量)赋初始值，也即为它们在方法区划分内存空间。这里注意是**静态变量**，并且是初始值，比如 int 的初始值是 0。

- 解析：将常量池的符号引用转化成直接引用。符号引用可以理解为只是个替代的标签，比如你此时要做一个计划，暂时还没有人选，你设定了个 A 去做这个事。然后等计划真的要落地的时候肯定要找到确定的人选，到时候就是小明去做一件事。

  解析就是把 A(符号引用) 替换成小明(直接引用)。符号引用就是一个字面量，没有什么实质性的意义，只是一个代表。直接引用指的是一个真实引用，在内存中可以通过这个引用查找到目标。

- 初始化：这时候就执行一些静态代码块，为静态变量赋值，这里的赋值才是代码里面的赋值，准备阶段只是设置初始值占个坑。

这个问题我觉得回答可以比我写的更粗，几个阶段一说，大致做的说一说就 ok 了。

想要知道更详细的流程可以看下《深入理解虚拟机Java》虚拟机的类加载章节。

## 双亲委派知道不？来说说看？

类加载机制一问基本上就会接着问双亲委派。

**双亲委派的意思是**：

如果一个类加载器需要加载类，那么首先它会把这个类加载请求委派给父类加载器去完成，如果父类还有父类则接着委托，每一层都是如此。

一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。

这里的双亲其实就指的是父类，没有mother。

父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。

关于双亲委派我之前写过文章，我把一些比较重要的内容拷过来：

Java 自身提供了 3 种类加载器：

1. 启动类加载器(Bootstrap ClassLoader)，它是属于虚拟机自身的一部分，用 C++ 实现的，主要负责加载`<JAVA_HOME>\lib`目录中或被-Xbootclasspath指定的路径中的并且文件名是被虚拟机识别的文件。它是所有类加载器的爸爸。

2. 扩展类加载器(Extension ClassLoader),它是Java实现的，独立于虚拟机，主要负责加载`<JAVA_HOME>\lib\ext`目录中或被java.ext.dirs系统变量所指定的路径的类库。

3. 应用程序类加载器(Application ClassLoader),它是Java实现的，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那这玩意就是我们程序中的默认加载器。

所以一般情况类加载会从应用程序类加载器委托给扩展类再委托给启动类，启动类找不到然后扩展类找，扩展类加载器找不到再应用程序类加载器找。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228112334820.png)


**双亲委派模型不是一种强制性约束**，也就是你不这么做也不会报错怎样的，**它是一种JAVA设计者推荐使用类加载器的方式**。 

> 为什么要双亲委派？

它使得类有了层次的划分。就拿 java.lang.Object 来说，加载它经过一层层委托最终是由Bootstrap ClassLoader来加载的，也就是最终都是由Bootstrap ClassLoader去找<JAVA_HOME>\lib中rt.jar里面的java.lang.Object加载到JVM中。

这样如果有不法分子自己造了个java.lang.Object,里面嵌了不好的代码，如果我们是按照双亲委派模型来实现的话，最终加载到JVM中的只会是我们rt.jar里面的东西，也就是这些核心的基础类代码得到了保护。

因为这个机制使得系统中只会出现一个java.lang.Object。不会乱套了。你想想如果我们JVM里面有两个Object，那岂不是天下大乱了。

> 那你知道有违反双亲委派的例子吗？

典型的例子就是：JDBC。

JDBC 的接口是类库定义的，但实现是在各大数据库厂商提供的 jar 包中，那通过启动类加载器是找不到这个实现类的，所以就需要应用程序加载器去完成这个任务，这就违反了自下而上的委托机制了。

具体做法是搞了个**线程上下文类加载器**，通过 setContextClassLoader() 默认设置了应用程序类加载器，然后通过 Thread.current.currentThread().getContextClassLoader() 获得类加载器来加载。

更详细的可以看下我之前写的这篇文章：[美团五面：Java历史上有三次破坏双亲委派模型，是哪三次？](https://mp.weixin.qq.com/s/zZmsi7lpuQHECOHA2ohOvA)



---

TBC。

有更多相关的Java基础面试题，可以提PR哈，有错误欢迎联系我。

除了这个系列，我的公众号每周至少都会有一篇原创，欢迎关注~

![](https://gitee.com/yessimida/interview-of-legends/raw/master/pic/16034279-e6ebb79b5a0b8fe7.png)

最近已经汇集了近 500 名朋友交流各大小厂面试真题，也期待各位的面试题分享，公众号有我的联系方式，如果有兴趣可以加我备注 **面霸**，拉你进真题交流群。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/image-20210228190741512.png)

