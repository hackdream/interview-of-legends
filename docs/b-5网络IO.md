## I/O到底是什么?

I/O 其实就是 input 和 output 的缩写，即输入/输出。

那输入输出啥呢？

比如我们用键盘来敲代码其实就是输入，那显示器显示图案就是输出，这其实就是 I/O。

而我们时常关心的磁盘 I/O 指的是硬盘和内存之间的输入输出。

读取本地文件的时候，要将磁盘的数据拷贝到内存中，修改本地文件的时候，需要把修改后的数据拷贝到磁盘中。

网络 I/O 指的是网卡与内存之间的输入输出。

当网络上的数据到来时，网卡需要将数据拷贝到内存中。当要发送数据给网络上的其他人时，需要将数据从内存拷贝到网卡里。

那为什么都要跟内存交互呢?

我们的指令最终是由 CPU 执行的，究其原因是 CPU 与内存交互的速度远高于 CPU 和这些外部设备直接交互的速度。

因此都是和内存交互，当然假设没有内存，让 CPU 直接和外部设备交互，那也算 I/O。

总结下：I/O 就是指内存与外部设备之间的交互（数据拷贝）。

## 为什么网络 I/O 会被阻塞？

其实了解了 Socket 的通讯内幕就能回答这个问题。

详细来看这个问题要从建连和通讯涉及到个各个方法来入手，分别是 accept、connect、read、write 。

我们慢慢分析下。

### 创建 socket

首先服务端需要先创建一个 socket。在 Linux 中一切都是文件，那么创建的 socket 也是文件，每个文件都有一个整型的文件描述符（fd）来指代这个文件。

`int socket(int domain, int type, int protocol);`

- domain：这个参数用于选择通信的协议族，比如选择 IPv4 通信，还是 IPv6 通信等等
- type：选择套接字类型，可选字节流套接字、数据报套接字等等。
- protocol：指定使用的协议。

这个 protocol 通常可以设为 0 ，因为由前面两个参数可以推断出所要使用的协议。

比如`socket(AF_INET, SOCK_STREAM, 0);`，表明使用 IPv4 ，且使用字节流套接字，可以判断使用的协议为 TCP 协议。

这个方法的返回值为 int ，其实就是创建的 socket 的 fd。

### bind

现在我们已经创建了一个 socket，但现在还没有地址指向这个 socket。

众所周知，服务器应用需要指明 IP 和端口，这样客户端才好找上门来要服务，所以此时我们需要指定一个地址和端口来与这个 socket 绑定一下。

`int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`

参数里的 sockfd 就是我们创建的 socket 的文件描述符，执行了 bind 参数之后我们的 socket 距离可以被访问又更近了一步。

### listen

执行了 socket、bind 之后，此时的 socket 还处于 closed 的状态，也就是不对外监听的，然后我们需要调用 listen 方法，让 socket 进入**被动监听**状态，这样的 socket 才能够监听到客户端的连接请求。

`int listen(int sockfd, int backlog);`

传入创建的 socket 的 fd，并且指明一下 backlog 的大小。

这个 backlog 我查阅资料的时候，看到了三种解释：

1. socket 有一个队列，同时存放已完成的连接和半连接，backlog为这个队列的大小。
2. socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog为这个两个队列的大小之和。
3. socket 有两个队列，分别为已完成的连接队列和半连接队列，backlog仅为已完成的连接队列大小。

> 解释下什么叫半连接

我们都知道 TCP 建立连接需要三次握手，当接收方收到请求方的建连请求后会返回 ack，此时这个连接在接收方就处于半连接状态，当接收方再收到请求方的 ack 时，这个连接就处于已完成状态：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170557.png)

所以上面讨论的就是这两种状态的连接的存放问题。

我查阅资料看到，基于 BSD 派生的系统的实现是使用的一个队列来同时存放这两种状态的连接， backlog 参数即为这个队列的大小。

而 Linux 则使用两个队列分别存储已完成连接和半连接，**且 backlog 仅为已完成连接的队列大小**

### accept

现在我们已经初始化好监听套接字了，此时会有客户端连上来，然后我们需要处理这些已经完成建连的连接。

从上面的分析我们可以得知，三次握手完成后的连接会被加入到已完成连接队列中去。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170607.png)

这时候，我们就需要从已完成连接队列中拿到连接进行处理，这个拿取动作就由 accpet 来完成。

`int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);`

这个方法返回的 int 值就是拿到的已完成连接的 socket 的文件描述符，之后操作这个 socket 就可以进行通信了。

如果已完成连接队列没有连接可以取，那么调用 accept 的线程会**阻塞等待**。

> 至此服务端的通信流程暂告一段落，我们再看看客户端的操作。

### connect

客户端也需要创建一个 socket，也就是调用 `socket()`，这里就不赘述了，我们直接开始建连操作。

客户端需要与服务端建立连接，在 TCP 协议下开始经典的三次握手操作，再看一下上面画的图：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170617.png)

客户端创建完 socket 并调用 `connect` 之后，连接就处于 `SYN_SEND` 状态，当收到服务端的 `SYN+ACK` 之后，连接就变为 `ESTABLISHED` 状态，此时就代表三次握手完毕。

`int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);`

调用`connect`需要指定远程的地址和端口进行建连，三次握手完毕之后就可以开始通信了。

客户端这边不需要调用 bind 操作，默认会选择源 IP 和随机端口。

用一幅图来小结一下建连的操作：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170626.png)

可以看到这里的两个阻塞点：

- connect：需要阻塞等待三次握手的完成。
- accept：需要等待可用的已完成的连接，如果已完成连接队列为空，则被阻塞。

### read、write

连接建立成功之后，就能开始发送和接收消息了，我们来看一下

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170639.png)

read 为读数据，从服务端来看就是等待客户端的请求，如果客户端不发请求，那么调用 read 会处于阻塞等待状态，没有数据可以读，这个应该很好理解。

write 为写数据，一般而言服务端接受客户端的请求之后，会进行一些逻辑处理，然后再把结果返回给客户端，这个写入也可能会被阻塞。

这里可能有人就会问 read 读不到数据阻塞等待可以理解，write 为什么还要阻塞，有数据不就直接发了吗？

因为我们用的是 TCP 协议，**TCP 协议需要保证数据可靠地、有序地传输，并且给予端与端之间的流量控制**。

所以说发送不是直接发出去，它有个**发送缓冲区**，我们需要把数据先拷贝到 TCP 的发送缓冲区，由 TCP 自行控制发送的时间和逻辑，有可能还有重传什么的。

如果我们发的过快，导致接收方处理不过来，那么接收方就会通过 TCP 协议告知：别发了！忙不过来了。**发送缓存区是有大小限制的**，由于无法发送，还不断调用 write 那么缓存区就满了，满了就不然你 write 了，所以 write 也会发生阻塞。

综上，read 和 write 都会发生阻塞。

### 所以为什么网络 I/O 会发生阻塞？

因为建连和通信涉及到的 accept、connect、read、write 这几个方法都可能会发生阻塞。

阻塞会占用当前执行的线程，使之不能进行其他操作，并且频繁阻塞唤醒切换上下文也会导致性能的下降。

由于阻塞的缘故，起初的解决的方案就是建立多个线程，但是随着互联网的发展，用户激增，连接数也随着激增，需要建立的线程数也随着一起增加，到后来就产生了 C10K 问题。

服务端顶不住了呀，咋办？

优化呗！

所以后来就弄了个非阻塞套接字，然后 I/O多路复用、信号驱动I/O、异步I/O。

## I/O模型有哪些？

以 read 调用，即读取网络数据为例子来展开 I/O 模型。

### 同步阻塞 I/O 

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170911.png)

当用户程序的线程调用 read 获取网络数据的时候，首先这个数据得有，也就是网卡得先收到客户端的数据，然后这个数据有了之后需要拷贝到内核中，然后再被拷贝到用户空间内，这整一个过程用户线程都是被阻塞的。

假设没有客户端发数据过来，那么这个用户线程就会一直阻塞等着，直到有数据。即使有数据，那么两次拷贝的过程也得阻塞等着。

所以这称为同步阻塞 I/O 模型。

它的优点很明显，简单。调用 read 之后就不管了，直到数据来了且准备好了进行处理即可。

缺点也很明显，**一个线程对应一个连接**，一直被霸占着，即使网卡没有数据到来，也同步阻塞等着。

我们都知道线程是属于比较重资源，这就有点浪费了。

所以我们不想让它这样傻等着。

于是就有了同步非阻塞 I/O。

### 同步非阻塞 I/O 

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170857.png)

从图中我们可以很清晰的看到，同步非阻塞I/O 基于同步阻塞I/O 进行了优化：

在没数据的时候可以不再傻傻地阻塞等着，而是直接返回错误，告知暂无准备就绪的数据！

这里要注意，**从内核拷贝到用户空间这一步，用户线程还是会被阻塞的**。

这个模型相比于同步阻塞 I/O 而言比较灵活，比如调用 read 如果暂无数据，则线程可以先去干干别的事情，然后再来继续调用 read 看看有没有数据。

但是如果你的线程就是取数据然后处理数据，不干别的逻辑，那这个模型又有点问题了。

等于你不断地进行系统调用，如果你的服务器需要处理海量的连接，那么就需要有海量的线程不断调用，上下文切换频繁，CPU 也会忙死，做无用功而忙死。

那怎么办？

于是就有了I/O 多路复用。

### I/O 多路复用

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123170951.png)

从图上来看，好像和上面的同步非阻塞 I/O 差不多啊，其实不太一样，**线程模型不一样**。

既然同步非阻塞 I/O 在太多的连接下频繁调用太浪费了， 那就招个专员吧。

这个专员工作就是管理多个连接，帮忙查看连接上是否有数据已准备就绪。

也就是说，**可以只用一个线程查看多个连接是否有数据已准备就绪**。

具体到代码上，这个专员就是  select ，我们可以往 select 注册需要被监听的连接，由 select 来监控它所管理的连接是否有数据已就绪，如果有则**可以**通知别的线程来 read 读取数据，**这个 read 和之前的一样，还是会阻塞用户线程**。

这样一来就可以**用少量的线程去监控多条连接**，减少了线程的数量，降低了内存的消耗且减少了上下文切换的次数，很舒服。

想必到此你已经理解了什么叫 I/O 多路复用。

所谓的多路指的是多条连接，复用指的是用一个线程就可以监控这么多条连接。

看到这，你再想想，还有什么地方可以优化的？

### 信号驱动式I/O

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123171042.png)

上面的 select 虽然不阻塞了，但是他得时刻去查询看看是否有数据已经准备就绪，那是不是可以让内核告诉我们数据到了而不是我们去轮询呢？

信号驱动 I/O 就能实现这个功能，由内核告知数据已准备就绪，然后用户线程再去 read（还是会阻塞）。

听起来是不是比 I/O 多路复用好呀？那为什么好像很少听到信号驱动 I/O？

> 为什么市面上用的都是 I/O 多路复用而不是信号驱动?

因为我们的应用通常用的都是 TCP 协议，而 **TCP 协议的 socket 可以产生信号事件有七种**。

也就是说不仅仅只有数据准备就绪才会发信号，其他事件也会发信号，而这个信号又是同一个信号，所以我们的应用程序无从区分到底是什么事件产生的这个信号。

那就麻了呀！

所以我们的应用基本上用不了信号驱动 I/O，但如果你的应用程序用的是 UDP 协议，那是可以的，因为 UDP 没这么多事件。

因此，这么一看对我们而言信号驱动 I/O 也不太行。

### 异步 I/O

信号驱动 I/O 虽然对 TCP 不太友好，但是这个思路对的：**往异步发展**，但是它并没有完全异步，因为其后面那段 read 还是会阻塞用户线程，所以它算是半异步。

因此，我们得想下如何弄成全异步的，也就是把 read 那步阻塞也省了。

其实思路很清晰：让内核直接把数据拷贝到用户空间之后再告知用户线程，来实现真正的非阻塞I/O！

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123171103.png)

所以异步 I/O 其实就是用户线程调用 `aio_read` ，然后包括将数据从内核拷贝到用户空间那步，所有操作都由内核完成，当内核操作完毕之后，再调用之前设置的回调，此时用户线程就拿着已经拷贝到用户控件的数据可以继续执行后续操作。

在整个过程中，用户线程没有任何阻塞点，**这才是真正的非阻塞I/O**。

那么问题又来了:

> 为什么常用的还是I/O多路复用，而不是异步I/O？

因为 Linux 对异步 I/O 的支持不足，你可以认为还未完全实现，所以用不了异步 I/O。

这里可能有人会说不对呀，像 Tomcat 都实现了 AIO的实现类，其实像这些组件或者你使用的一些类库看起来支持了 AIO(异步I/O)，**实际上底层实现是用 epoll 模拟实现的**。

而 Windows 是实现了真正的 AIO，不过我们的服务器一般都是部署在 Linux 上的，所以主流还是 I/O 多路复用。

## 同步和异步的区别？

同步和异步指的是：当前线程是否需要等待方法调用执行完毕。

比如你调用一个搬运一百块石头的方法：
- 同步指的是调用这个方法，你的线程需要等待这一百块石头搬完，然后得到搬完了的结果，接着再继续执行剩下的代码逻辑。

```java
//同步方式

result = 搬一百块石头();
//需等待搬完的结果，才能执行下面的逻辑
if(result) {
石头搬完了发工资();
}
计算下一次搬石头的任务()；
```

- 异步指的是调用这个方法，立马就直接返回，不必等候这一百块石头还未搬完，可以立马执行后面的代码逻辑，然后利用回调或者事件通知的方式得到石头已经搬完的结果。

```java
//异步方式

搬一百块石头({
    //回调
	石头搬完了发工资();
});
//不必等待石头搬完，立马执行下面的逻辑
计算下一次搬石头的任务()；
```

可以很直观的看出，同步和异步就是调用方式的不同，这使得我们的编码方式也有所不同。

在异步调用下的代码逻辑相对而言不太直观，需要借助回调或事件通知，这在复杂逻辑下对编码能力的要求较高。而同步调用就是直来直去，等待执行完毕然后拿到结果紧接着执行下面的逻辑，对编码能力的要求较低，也更不容易出错。

所以你会发现有很多方法它是异步调用的方式，但是最终的使用还是异步转同步。

比如你向线程池提交一个任务，得到一个 future，此时是异步的，然后你在紧接着在代码里调用 `future.get()`，那就变成等待这个任务执行完成，这就是所谓的异步转同步，像 Dubbo RPC 调用同步得到返回结果就是这样实现的。

## 阻塞和非阻塞的区别？

阻塞和非阻塞指的是：当前接口数据还未准备就绪时，线程是否被阻塞挂起。

何为阻塞挂起？就是当前线程还处于 CPU 时间片当中，调用了阻塞的方法，由于数据未准备就绪，则时间片还未到就让出 CPU。

所以阻塞和同步看起来都是等，但是本质上它们不一样，同步的时候可没有让出 CPU。

而非阻塞就是当前接口数据还未准备就绪时，线程不会被阻塞挂起，可以不断轮询请求接口，看看数据是否已经准备就绪。

至此我们可以得到一个结论：

- 同步&异步指：当数据还未处理完成时，代码的逻辑处理方式不同。
- 阻塞&非阻塞指：当数据还未处理完成时(未就绪)，线程的状态。

所以同步&异步其实是处于框架这种高层次维度来看待的，而阻塞&非阻塞往往针对底层的系统调用方面来抉择，也就是说两者是从不同维度来考虑的。

## 同步、异步、阻塞、非阻塞的I/O的区别？

> 前提：程序和硬件之间隔了个操作系统，而为了安全考虑，Linux 系统分了：用户态和内核态

在这个前提下，我们再明确 I/O 操作有两个步骤：

1. 发起 I/O 请求
2. 实际 I/O 读写，即数据从内核缓存拷贝到用户空间

**阻塞 I/O 和非阻塞 I/O**。按照上文，其实指的就是用户线程是否被阻塞，这里指代的步骤1（发起I/O请求）。

- 阻塞 I/O，指用户线程发起 I/O 请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），就会阻塞当前线程，让出 CPU。
- 非阻塞 I/O，指用户线程发起 I/O 请求的时候，如果数据还未准备就绪（例如暂无网络数据接收），也不会阻塞当前线程，可以继续执行后续的任务。

可以发现，这里的阻塞和非阻塞其实是指用户线程是否会被阻塞。

**同步 I/O 和异步 I/O**。按照上文，我们可以得知这就是根据 I/O 响应方式不同而划分的。

- 同步 I/O，指用户线程发起 I/O 请求的时候，数据是有的，那么将进行步骤2（实际 I/O 读写，即数据从内核缓存拷贝到用户空间），这个过程用户线程是要等待着拷贝完成。
- 异步 I/O，指用户线程发起 I/O 请求的时候，数据是有的，那么将进行步骤2（实际 I/O 读写，即数据从内核缓存拷贝到用户空间），拷贝的过程中不需要用户线程等待，用户线程可以去执行其它逻辑，等内核将数据从内核空间拷贝到用户空间后，用户线程会得到一个“通知”。

再仔细思考下，在 I/O 场景下同步和异步说的其实是内核的实现，因为拷贝的执行者是内核，一种是同步将数据拷贝到用户空间，用户线程是需要等着的。一个是通过异步的方式，用户线程不用等，在拷贝完之后，内核会调用指定的回调函数。

如果不理解上面，就只需记住：

- 同步I/O：指的是用户线程会需要等待步骤 2 执行完毕。
- 异步I/O：指的是用户线程不需要等待步骤 2 执行。

好了，如果以上的概念你都已经理解了的话，那么平日里我们所说的同步阻塞I/O，同步非阻塞I/O等其实就是把上面的两个步骤合起来看，应该不难理解。

我再简单的总结一下，关于 I/O 的阻塞、非阻塞、同步、异步：

- 阻塞和非阻塞指的是发起 I/O 请求后，用户线程状态的不同，阻塞I/O在数据未准备就绪的时候会阻塞当前用户线程，而非阻塞 I/O 会立马返回一个错误，不会阻塞当前用户线程。
- 同步和异步是指，内核的 I/O 拷贝实现，当数据准备就绪后，需要将内核空间的数据拷贝至用户空间，如果是同步 I/O 那么用户线程会等待拷贝的完成，而异步 I/O则这个拷贝过程用户线程该干嘛可以去干吗，当内核拷贝完毕之后会“通知”用户线程。

要注意，不同场景下同一个名词意义可能不同。我这篇关于同步、异步、阻塞、非阻塞这几个概念是基于 I/O 场景下讲的。

## BIO、NIO、AIO？

BIO 指的是同步阻塞I/O，在这种模型下只能是来一个连接用一个线程，连接多并发大的话服务器顶不住这么多线程的。

NIO 指的是同步非阻塞I/O，我们熟知的 IO 多路复用就是NIO，适合用在连接多、每次传输较为短的场景。

AIO 指的是异步I/O，调用了之后就不管了，数据来了自动会执行回调方法。异步可以有效的减少线程的等待，减少了用户线程拷贝数据的那段等待，效率更高。

## 什么是 Channel？

翻译过来就是通道。

我们可以往通道里写数据，也可以从通道里读数据，它是双向的，而与之配套的是 Buffer，也就是你想要往一个通道里写数据，必须要将数据写到一个 Buffer 中，然后写到通道里。

从通道里读数据，必须将通道的数据先读取到一个 Buffer 中，然后再操作。

在 NIO 中 Channel 有多种类型：

- SocketChannel
- ServerSocketChannel
- DatagramChannel
- FileChannel

###  SocketChannel
对标 Socket，**我们可以直接将它当做所建立的连接**。

通过 SocketChannel ，我们可以利用 TCP 协议进行读写网络数据。

### ServerSocketChannel
可以对标 ServerSocket，也就是服务端创建的 Socket。

它的作用就是监听新建连的 TCP 连接，为新进一个连接创建对应的 SocketChannel。

之后，通过新建的 SocketChannel 就可以进行网络数据的读写，与对端交互。

可以看到它主要是用来接待新连接，这功能主要就是服务端做的，所以叫 **Server**SocketChannel。

###  DatagramChannel
看到 Datagram 应该就知道是 UDP 协议了，是无连接协议。

利用 DatagramChannel 可以直接通过 UDP 进行网络数据的读写。

### FileChannel
文件通道，用来进行文件的数据读写。

我们日常开发主要是基于 TCP 协议，所以我们把精力放在  SocketChannel 和  ServerSocketChannel 上即可。

我们再回过头来继续看看 SocketChannel 和 ServerSocketChannel。

SocketChannel 主要在两个地方出现：

1. 客户端，客户端创建一个 SocketChannel 用于连接至远程的服务端。
2. 服务端，服务端利用 ServerSocketChannel 接收新连接之后，为其创建一个 SocketChannel 。

随后，客户端和服务端就可以通过这两个 SocketChannel 相互发送和接收数据。

ServerSocketChannel 主要出现在一个地方：服务端。

服务端需要绑定一个端口，然后监听新连接的到来，这个活儿就由 ServerSocketChannel 来干。

服务端内常常会利用一个线程，一个死循环，不断地接收新连接的到来。

```java
ServerSocketChannel serverSocketChannel 
		= ServerSocketChannel.open();
	......
while(true){
  // 接收的新连接
  SocketChannel socketChannel =
      serverSocketChannel.accept();
	.......
}
```

至此，想必你应该清楚 ServerSocketChannel  和 SocketChannel 的区别和作用了。

## 什么是 Buffer？

Buffer 说白了就是内存中可以读写的一块地方，叫缓冲区，用于缓存数据。

其实还真没啥好说的，最多就讲讲 Java NIO Buffer 的 API。

但讲 API 的太死板了，所以自己上网搜搜吧。我就告知一个结论，这个 API 很不好用，稍微漏写了点，就容易出 bug，而且还有很多优化的之处，所以 Netty 没用 Java NIO Buffer 而是自己实现了一个 Buffer，叫 ByteBuf。

等我们之后分析 ByteBuf 的时候再来盘一盘。现在你只需要知道 Buffer 主要用来缓存通道的读写数据即可。

对了，看到这可能会有人提出疑问，为什么 Channel 必须和 Buffer 搭配使用？

其实网络数据是面向字节的，但是我们读写的数据往往是多字节的，假设不用 Buffer ，那我们就得一个字节一个字节的调用读和调用写，想想是不是很麻烦？

所以我们搞个 Buffer，把数据拢一拢，这样之后的调用才能更好地处理完整的数据，方便异步的处理等等。

## 什么是 Selector？

I/O多路复用的核心玩意。

一个 Selector 上可以注册多个 Channel ，我们从上面得知一个 Channel 就对应了一个连接，因此一个 Selector 可以管理多个 Channel 。

具体管理什么？

当任意 Channel 发生读写事件的时候，通过 `Selector.select()` 就可以捕捉到事件的发生，因此我们利用一个线程，死循环的调用 `Selector.select()`，这样可以利用一个线程管理多个连接，减少了线程数，减少了线程的上下文切换和节省了线程资源。

这就是 Selector 的核心功能，然后我们再来细说具体是怎样管理的。

首先，创建一个 Selector。

```
Selector selector = Selector.open();
```

然后，你需要将被管理的 Channel 注册到  Selector 上，并声明感兴趣的事件。

```java
SelectionKey key = channel.register(selector, Selectionkey.OP_READ);
```
![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123171506.png)

事件一共有以上四种类型，注册的时候可以同时对多种类型的事件感兴趣，例如：


```java
SelectionKey key 
  = channel.register(selector, 
  	Selectionkey.OP_READ | SelectionKey.OP_WRITE);
```
这样，当这个 Channel 发生读或写事件，我们调用 `Selector.select()` 就可以得知有事件发生。

具体 Selector.select() 有三个重载方法：

- int selectNow()，不论是否有无事件发生，立即返回
- int select(long timeout)，至多阻塞 timeout 时间（或被唤醒），如果提早有事件发生，提早返回
- int select()，一直阻塞着，直到有事件发生（或被唤醒）

返回值就是就绪的通道数，一般判断大于 0 即可进行后续的操作。

后续的操作就是调用：

```java
Set selectedKeys = selector.selectedKeys();
```

获得了一个类型为 Set 的 selectedKeys 集合，那这个 selectedKeys  又是啥玩意？

我们来看一下它的方法和成员：

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123171522.png)

看到这些成员，其实我们就很清晰了，我们可以通过 selectedKey 得知当前发生的是什么事件，有 isAcceptable、isReadable 等等。

然后还能获得对应的 channel 进行相应的读写操作，还有获取 attachment 等等。

所以得到了 selectedKeys 就可以**通过迭代器遍历所有发生事件的连接**，然后进行操作。

大致使用的代码如下所示：

```java
while(true) {
	int readyNum = selector.select();
	if (readyNum == 0) {
	   continue;
	}
	Set selectedKeys = selector.selectedKeys();
	Iterator keyIterator = selectedKeys.iterator();
	while(keyIterator.hasNext()) {
	   SelectionKey key = keyIterator.next();
	   if(key.isAcceptable()) {
	       // a connection was accepted by a ServerSocketChannel.
	   } else if (key.isConnectable()) {
	       // a connection was established with a remote server.
	   } else if (key.isReadable()) {
	       // a channel is ready for reading
	   } else if (key.isWritable()) {
	       // a channel is ready for writing
	   }
	   keyIterator.remove(); //执行完毕之后，需要在循环内移除自己
	}
}
```

还有个方法就是 `Selector.wakeup()`，可以唤醒阻塞着的 Selector。

对了还有一点没说，就是如果 Channel 要和 Selector 搭配，那它必须得是非阻塞的，即配置

```java
channel.configureBlocking(false);
```

从上面的操作，我们可以得知 Selector 处理事件的时候必须快，如果长时间处理某个事件，那么注册到 Selector 上的其他连接的事件就不会被及时处理，造成客户端阻塞。

至此，想必你应该清晰 Selector 具体是如何管理这么多连接的了。

## 到底什么是 Ractor？

Reactor 是个啥呢？其实它算是一个编程模式或者说一个架构模式，常用在**服务端**网络通信相关的模块。

Reactor 直译到中文是反应堆，虽然直译不贴切，但确实跟“反应”有关。

反应啥呢？**对触发的事件进行反应**。

在大学的时候，我相信很多人都做过图书管理系统等类似的大作业，这种都是基于 Java GUI 做的，当然具体如何实现的不重要，重要的是你完成之后的成品是不是点击一个按钮就会弹出一个对应的弹框？

点击按钮就会弹框，不同的按钮弹不同的框，这就是反应。

咱们计算机不就讲究抽象嘛，所以把这上面说的这些抽象一下，**就是针对不同的事件需要有不同的处理逻辑（方法调用）**。

到这，我们得到了两个概念：事件（点击按钮）和处理逻辑（弹对应的框）。

再回到弹框这个场景，思考下，到底是谁在监听着按钮被点击的动作来弹出不同的框呢？

这里，我们很容易想到两种情况：

1. 一个按钮派一个线程在守着，只要按钮被点击了，这个线程就执行弹框
2. 一个线程轮询所有按钮的情况，死循环查看只要有一个按钮被点击了，就找出按钮绑定的框，然后弹

如果按钮很少，其实多派几个线程守着影响不大，假设有一千个、一万个按钮呢？这种场景下第二种实现更优，毕竟按钮也不是一直会被点击着，对吧。

我们把“人”、“点击按钮”、“弹框”对应到网络编程中，就是线程、事件、处理。

第一种情况翻译过来就是一个线程接待一个连接，每当连接上有事件产生，则线程会对应事件作出响应。

这对应着很早之前的网络编程模型，那时候网上没那么多用户，并且也就只有阻塞 I/O，如果连接没有反应，那么线程就得阻塞等待着 I/O 事件的发生。

第二种情况翻译过来就是，由一个线程接待多个连接，不论哪个连接上有事件产生，这个线程都会根据事件找到对应的处理逻辑来作出响应。

这就是对应现在流行的基于非阻塞 I/O 的 I/O 多路复用，这种场景就适合海量用户的情况，服务端可用很少线程来处理数量庞大的连接，就像我上面说的，毕竟连接（按钮）也不是一直会有请求过来（被点击）。

至于我前头提到的事件，**基础的** I/O 上的事件也就这三种：连接事件、读事件、写事件。

现在回到网络 I/O 上，我们再来看 Reactor：也就是有一个 selector（select/poll/epoll） 线程，它管理着很多连接，只要某个连接上有事件产生，就会唤醒 selector 线程，这个线程就会根据发生的事件类型做不同的处理。

这就是 Reactor，对应的线程也叫 Reactor 线程（就靠它起反应啦）。

那没 Reactor 的场景是怎样的？

就是上面提的第一种情况，一个线程接待一条连接。不像第二种情况这样，由一个线程来接待许多连接，由一个“负责人”来接待多个客户，这种什么事都找一个人，是不是感受起来那个人就像一个 Reactor？

**能一对多的根据不同请求做出不同响应实现**，是我个人认为的 Reactor 核心。至于事件、调度器、Acceptor等玩意，我觉得是为了写论文或者文章必须要搞的一些概念，反正理解了之后，也就这么回事儿，因为要从流程上走通必须得有这么些个东西。

就像我们所知的 SpringMVC，要想一个请求能找到对应的 Controller，那不就得有个统一入口判断路由嘛，所以必须要有这么个东西，不然请求到不了 Controller 了啊，那这个玩意叫啥？不就是 DispatcherServlet 吗， 中文名不就是前置控制器吗。

所以，不是说 SpringMVC 需要有 DispatcherServlet 这么个玩意，而是 SpringMVC 需要有个统一入口判断路由，所以就弄了个实现类，这个实现类呢就叫 DispatcherServlet。

你懂我的意思吧。

同样看 Reactor 也是一样的，不是说 Reactor 需要有个叫 Demultiplexer、 Dispatcher、Handle、Event Handler 这么些个玩意才叫 Reactor 。

而是在网络 I/O 中基于非阻塞 I/O ，且需要少量的线程接待大量的连接，这样一场景下，就必须要个玩意作为一个监听者，监听底层这么多连接是否有请求，然后根据请求的类型（抽象的事件），指派调用不同的处理逻辑，才对应衍生出上面这么些个名词。

在具体的实现上， Demultiplexer 和 Dispatcher 当然可以是同一个线程，同在一个死循环里面，这都是 ok 的，不要看着名词就理解着，代码里必须分这么两个玩意，不是的哈。

基于上面的理解，然后再看看来自 Reactor 论文的这张图把，是不是好理解了。

![](https://cdn.jsdelivr.net/gh/yessimida/cdn_image/img/20220123171716.png)

最后再说个官方点的回答吧：

Reactor 是服务端在网络编程时的一个编程模式，主要由一个基于 Selector （底层是 select/poll/epoll）的死循环线程，也称为 Reactor 线程。将 I/O 操作抽象成不同的事件，每个事件都配置对应的回调函数，由 Selector 监听连接上事件的发生，再进行分发调用相应的回调函数进行事件的处理。